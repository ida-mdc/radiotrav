<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Radiation Events – Sliding Window Viewer</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://cdn.plot.ly/plotly-2.30.0.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.4.1/papaparse.min.js"></script>
  <style>
    body { font-family: 'Inter', sans-serif; background: #0b1220; color: #e5e7eb; }
    .card { background: #0f172a; border: 1px solid #1f2937; border-radius: 12px; padding: 16px; }
    .muted { color: #94a3b8; }
    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; }
    input[type="range"] { width: 100%; }
  </style>
</head>
<body>
  <div class="max-w-[1800px] mx-auto p-5">
    <div class="flex flex-col md:flex-row md:items-end md:justify-between gap-4 mb-4">
      <div>
        <div class="text-2xl font-bold">Radiation Events - Sliding Window XY Viewer</div>
      </div>
      <div class="card flex flex-col gap-2">
        <div class="text-xs font-semibold muted">LOAD FILES</div>
        <div class="flex flex-col gap-2">
          <label class="text-sm">Events file (TXT with time/x/y, or raw .t3pa; Cluster_ID optional)</label>
          <input id="eventsFile" type="file" accept=".txt,.t3pa,.t3p" class="text-sm" />
          <label class="text-sm">Classification CSV (optional; for class colors)</label>
          <input id="classFile" type="file" accept=".csv" class="text-sm" />
        </div>
      </div>
    </div>

    <div class="grid grid-cols-1 lg:grid-cols-4 gap-4">
      <div class="lg:col-span-3 card">
        <div id="plot" style="height: 72vh;"></div>
      </div>
      <div class="lg:col-span-1 card">
        <div class="text-sm font-semibold mb-2">Controls</div>

        <div class="mb-3">
          <div class="flex items-center justify-between">
            <div class="text-xs muted">Mode</div>
            <select id="mode" class="text-xs bg-slate-900 border border-slate-700 rounded px-2 py-1">
              <option value="classification">Classification</option>
              <option value="energy">Energy (ToT)</option>
              <option value="density">Density (events / pixel)</option>
            </select>
          </div>
        </div>

        <div class="mb-3">
          <div class="flex items-center justify-between">
            <div class="text-xs muted">Time center</div>
            <div id="tCenterLabel" class="text-xs mono">-</div>
          </div>
          <input id="tCenter" type="range" min="0" max="1" step="0.001" value="0" />
        </div>

        <div class="mb-3">
          <div class="flex items-center justify-between">
            <div class="text-xs muted">Window size</div>
            <div id="winLabel" class="text-xs mono">-</div>
          </div>
          <input id="winSize" type="range" min="1" max="1000000" step="1" value="1000000" />
        </div>

        <div class="flex items-center gap-2 mb-3">
          <button id="playBtn" class="px-3 py-1 rounded bg-emerald-600 hover:bg-emerald-500 text-sm font-semibold">Play</button>
          <button id="resetBtn" class="px-3 py-1 rounded bg-slate-700 hover:bg-slate-600 text-sm font-semibold">Reset</button>
        </div>

        <div class="mb-3">
          <div class="flex items-center justify-between">
            <div class="text-xs muted">Playback speed</div>
            <div id="speedLabel" class="text-xs mono">1.0×</div>
          </div>
          <!-- 0.25× .. 4× -->
          <input id="speed" type="range" min="0.1" max="2" step="0.05" value="1" />
        </div>

        <div class="text-sm font-semibold mt-4 mb-2">Stats</div>
        <pre id="stats" class="mono text-xs whitespace-pre-wrap muted">Waiting for file...</pre>
        <div id="legend" class="mt-3 text-[11px] muted"></div>

      </div>
    </div>
  </div>

  <script>
    // -----------------------------
    // State
    // -----------------------------
    let events = null;   // {t, x, y, tot, cid}
    let classMap = null; // Map Cluster_ID -> class string
    let tMin = 0, tMax = 1;
    let isPlaying = false;
    let playTimer = null;

    const CLASS_RGB = {
      "Alpha": [220, 20, 20],
      "Beta":  [20, 180, 220],
      "Gamma": [20, 220, 20],
      "Other": [150, 150, 150]
    };

    function clamp01(v) { return Math.max(0, Math.min(1, v)); }
    function fmtSci(n) { return Number(n).toExponential(3); }
    function percentile(arr, p) {
      if (arr.length === 0) return 0;
      const sorted = [...arr].sort((a, b) => a - b);
      const idx = Math.ceil(sorted.length * p) - 1;
      return sorted[Math.max(0, Math.min(idx, sorted.length - 1))];
    }

    // -----------------------------
    // Parsing helpers
    // -----------------------------
    function parseWithPapa(file, opts = {}) {
      return new Promise((resolve, reject) => {
        Papa.parse(file, {
          header: true,
          dynamicTyping: true,
          skipEmptyLines: true,
          delimitersToGuess: [",", "\t", " ", ";"],
          ...opts,
          complete: (res) => resolve(res.data),
          error: (err) => reject(err)
        });
      });
    }

    function pick(row, keys, fallback = null) {
      for (const k of keys) {
        if (row[k] !== undefined && row[k] !== null && row[k] !== "") return row[k];
      }
      return fallback;
    }

    function normalizeColumns(rows) {
      // Handle quoted headers, dots, and whitespace in column names.
      // This lets us support both:
      // - TXT export columns like "arrival_time", "x_pos", "y_pos"
      // - T3PA columns like "Matrix Index", "ToA", "FToA", "ToT"
      return rows.map(r => {
        const out = {};
        for (const [k, v] of Object.entries(r)) {
          const kk = String(k)
            .replace(/"/g, "")
            .replace(/\./g, "_")
            .replace(/\s+/g, "_")
            .trim();
          out[kk] = v;
        }
        return out;
      });
    }

    // -----------------------------
    // Compute alpha fade
    // -----------------------------
    function alphaFade(t, center, win) {
      const half = win / 2;
      const d = Math.abs(t - center) / half;
      const dd = Math.max(0, Math.min(1, d));
      // Strong fade: 1 at center, 0 at edges (sharper than cosine)
      const base = 0.5 * (1 + Math.cos(Math.PI * dd));
      return Math.pow(base, 3);
    }

    // Turbo colormap approximation (matplotlib-like), returns [r,g,b] in 0..255
    function turboRgb01(x) {
      const t = clamp01(x);
      const r = 0.13572138 + t*(4.61539260 + t*(-42.66032258 + t*(132.13108234 + t*(-152.94239396 + t*59.28637943))));
      const g = 0.09140261 + t*(2.19418839 + t*(4.84296658 + t*(-14.18503333 + t*(4.27729857 + t*2.82956604))));
      const b = 0.10667330 + t*(12.64194608 + t*(-60.58204836 + t*(110.36276771 + t*(-89.90310912 + t*27.34824973))));
      return [clamp01(r), clamp01(g), clamp01(b)];
    }
    function turboRgb255(x) {
      const [r,g,b] = turboRgb01(x);
      return [Math.round(r*255), Math.round(g*255), Math.round(b*255)];
    }

    // -----------------------------
    // Rendering
    // -----------------------------
    function computeWindowData() {
      if (!events) return null;
      const centerFrac = Number(document.getElementById("tCenter").value);
      const center = tMin + centerFrac * (tMax - tMin);
      const win = Number(document.getElementById("winSize").value);
      const mode = document.getElementById("mode").value;
      const speed = Number(document.getElementById("speed").value);

      document.getElementById("tCenterLabel").textContent = fmtSci(center);
      document.getElementById("winLabel").textContent = fmtSci(win);
      document.getElementById("speedLabel").textContent = `${speed.toFixed(2)}×`;

      const lo = center - win / 2;
      const hi = center + win / 2;

      const x = [], y = [];
      const cidVis = [];
      const alpha = [];
      const energyVals = [];

      for (let i = 0; i < events.t.length; i++) {
        const ti = events.t[i];
        if (ti < lo || ti > hi) continue;

        const a = alphaFade(ti, center, win);
        if (a <= 0) continue;

        x.push(events.x[i]);
        y.push(events.y[i]);
        alpha.push(a);

        if (events.cid) cidVis.push(events.cid[i]);
        if (events.totNorm) energyVals.push(events.totNorm[i]);
      }

      let colors = [];
      let windowDensityMax = null;

      if (mode === "energy" && events.tot) {
        for (let i = 0; i < x.length; i++) {
          const v = clamp01(energyVals[i] ?? 0);
          const [r,g,b] = turboRgb255(v);
          const a = alpha[i];
          colors.push(`rgba(${r},${g},${b},${a.toFixed(6)})`);
        }
      } else if (mode === "density") {
        // Aggregate counts per (x,y) pixel
        const counts = new Map();
        for (let i = 0; i < x.length; i++) {
          const key = `${x[i]}|${y[i]}`;
          counts.set(key, (counts.get(key) || 0) + 1);
        }

        const xAgg = [], yAgg = [], alphaAgg = [];
        colors = [];

        // Per-window density - use 95th percentile to avoid outliers
        const countValues = Array.from(counts.values());
        const maxCountWindow = countValues.length > 0 ? percentile(countValues, 0.95) : 1;

        // Normalization cap: global max per-pixel density (95th percentile), but also respect
        // what is actually achievable in this window (95th percentile).
        const globalMax = events.densityGlobalMax || 1;
        const normMax = Math.max(1, Math.min(globalMax, maxCountWindow || 1));

        counts.forEach((cnt, key) => {
          const [xx, yy] = key.split("|").map(Number);
          // Normalize density against capped max for consistent legend
          const v = clamp01(cnt / normMax);
          const [r,g,b] = turboRgb255(v);
          xAgg.push(xx);
          yAgg.push(yy);
          alphaAgg.push(1.0); // fully opaque; density encodes in color
          colors.push(`rgba(${r},${g},${b},1.0)`);
        });

        // Replace arrays with aggregated ones
        x.length = 0; y.length = 0; alpha.length = 0;
        for (let i = 0; i < xAgg.length; i++) {
          x.push(xAgg[i]);
          y.push(yAgg[i]);
          alpha.push(alphaAgg[i]);
        }

        windowDensityMax = maxCountWindow || 1;
      } else {
        // classification or single-color fallback
        for (let i = 0; i < x.length; i++) {
          const a = alpha[i];
          if (events.cid && classMap) {
            const cls = classMap.get(cidVis[i]) || "Other";
            const [r,g,b] = CLASS_RGB[cls] || CLASS_RGB.Other;
            colors.push(`rgba(${r},${g},${b},${a.toFixed(6)})`);
          } else if (events.cid) {
            const id = cidVis[i];
            const r = (id * 53423423) % 256;
            const g = (id * 94235252) % 256;
            const b = (id * 19283741) % 256;
            colors.push(`rgba(${r},${g},${b},${a.toFixed(6)})`);
          } else {
            colors.push(`rgba(25,200,230,${a.toFixed(6)})`);
          }
        }
      }

      return {
        x, y, colors,
        nPoints: x.length,
        nClusters: events.cid ? new Set(cidVis).size : 0,
        tStart: center - win/2,
        tEnd: center + win/2,
        mode,
        speed,
        windowDensityMax,
        shapes: []
      };
    }

    async function renderPlot() {
      const d = computeWindowData();
      if (!d) return;

      const trace = {
        x: d.x,
        y: d.y,
        mode: "markers",
        type: "scattergl",
        marker: {
          size: 4,
          color: d.colors
        },
        hoverinfo: "skip"
      };

      const layout = {
        margin: {t: 10, r: 10, b: 40, l: 55},
        xaxis: {range: [0,256], title: "X", gridcolor: "rgba(148,163,184,0.15)", zeroline: false},
        yaxis: {range: [0,256], title: "Y", scaleanchor: "x", scaleratio: 1, gridcolor: "rgba(148,163,184,0.15)", zeroline: false},
        paper_bgcolor: "rgba(0,0,0,0)",
        plot_bgcolor: "rgba(0,0,0,0)",
        showlegend: false
      };

      const config = {responsive: true, displayModeBar: true};

      await Plotly.react("plot", [trace], layout, config);

      const stats = [
        `Mode: ${d.mode}`,
        `Events: ${d.nPoints}`,
        `Clusters: ${d.nClusters}`,
        `Time: ${fmtSci(d.tStart)} .. ${fmtSci(d.tEnd)}`,
        `Speed: ${d.speed.toFixed(2)}×`
      ].join("\n");
      document.getElementById("stats").textContent = stats;

      // Legend
      const legendEl = document.getElementById("legend");
      let legendHtml = "";
      if (d.mode === "classification") {
        legendHtml = `
          <div class="flex items-center gap-2 mb-1">
            <span class="inline-block w-3 h-3 rounded-sm" style="background: rgba(220,20,20,1)"></span><span>Alpha</span>
          </div>
          <div class="flex items-center gap-2 mb-1">
            <span class="inline-block w-3 h-3 rounded-sm" style="background: rgba(20,180,220,1)"></span><span>Beta</span>
          </div>
          <div class="flex items-center gap-2 mb-1">
            <span class="inline-block w-3 h-3 rounded-sm" style="background: rgba(20,220,20,1)"></span><span>Gamma</span>
          </div>
          <div class="flex items-center gap-2 mb-1">
            <span class="inline-block w-3 h-3 rounded-sm" style="background: rgba(150,150,150,1)"></span><span>Other</span>
          </div>
        `;
      } else if (d.mode === "energy") {
        const emin = (events && isFinite(events.energyMin)) ? events.energyMin : 0;
        const emax = (events && isFinite(events.energyMax)) ? events.energyMax : 1;
        const e0 = emin;
        const e25 = emin + 0.25*(emax - emin);
        const e50 = emin + 0.50*(emax - emin);
        const e75 = emin + 0.75*(emax - emin);
        const e1 = emax;
        legendHtml = `
          <div class="mb-1">Energy (ToT, no unit)</div>
          <div class="w-full h-3 rounded overflow-hidden mb-1" style="background: linear-gradient(to right,
            rgb(${turboRgb255(0).join(",")}),
            rgb(${turboRgb255(0.25).join(",")}),
            rgb(${turboRgb255(0.5).join(",")}),
            rgb(${turboRgb255(0.75).join(",")}),
            rgb(${turboRgb255(1).join(",")})
          )"></div>
          <div class="flex justify-between mono">
            <span>${e0.toFixed(2)}</span>
            <span>${e25.toFixed(2)}</span>
            <span>${e50.toFixed(2)}</span>
            <span>${e75.toFixed(2)}</span>
            <span>${e1.toFixed(2)}</span>
          </div>
        `;
      } else if (d.mode === "density") {
        const globalMax = (events && events.densityGlobalMax) ? events.densityGlobalMax : 1;
        const windowMax = d.windowDensityMax || globalMax;
        const maxC = Math.max(1, Math.min(globalMax, windowMax));
        const c0 = 1;
        const cMid = Math.max(1, Math.round(maxC / 2));
        legendHtml = `
          <div class="mb-1">Density (events / pixel)</div>
          <div class="w-full h-3 rounded overflow-hidden mb-1" style="background: linear-gradient(to right,
            rgb(${turboRgb255(0).join(",")}),
            rgb(${turboRgb255(0.25).join(",")}),
            rgb(${turboRgb255(0.5).join(",")}),
            rgb(${turboRgb255(0.75).join(",")}),
            rgb(${turboRgb255(1).join(",")})
          )"></div>
          <div class="flex justify-between mono">
            <span>${c0}</span><span>${cMid}</span><span>${maxC}</span>
          </div>
        `;
      }
      legendEl.innerHTML = legendHtml;
    }

    // -----------------------------
    // Loading files
    // -----------------------------
    async function loadEventsFile(file) {
      const rowsRaw = await parseWithPapa(file);
      const rows = normalizeColumns(rowsRaw);
      const t = [], x = [], y = [], tot = [], cid = [];

      for (const r of rows) {
        // --- Time ---
        // TXT: arrival_time / time
        // T3PA: ToA + FToA -> match collaborator R conversion:
        //   arrival_time = (ToA * 25) - ((FToA * 25)/16)
        let ti = pick(r, ["arrival_time", "time", "mean_t"], null);
        if (ti === null) {
          const toa = pick(r, ["ToA"], null);
          const ftoa = pick(r, ["FToA"], 0);
          if (toa !== null) {
            ti = (Number(toa) * 25.0) - ((Number(ftoa) * 25.0) / 16.0);
          }
        }

        // --- X/Y ---
        // TXT: x_pos/y_pos or x/y
        // T3PA: Matrix Index (or Matrix_Index after normalization)
        let xi = pick(r, ["x_pos", "x"], null);
        let yi = pick(r, ["y_pos", "y"], null);
        if (xi === null || yi === null) {
          const mi = pick(r, ["Matrix_Index", "MatrixIndex", "Matrix"], null);
          if (mi !== null) {
            const m = Number(mi);
            yi = Math.trunc(m / 256);
            xi = m - (yi * 256);
          }
        }

        if (ti === null || xi === null || yi === null) continue;
        t.push(Number(ti));
        x.push(Number(xi));
        y.push(Number(yi));

        const totv = pick(r, ["ToT", "tot"], null);
        tot.push(totv === null ? 0 : Number(totv));

        const cidi = pick(r, ["Cluster_ID", "cluster_id"], null);
        cid.push(cidi === null ? null : Number(cidi));
      }

      // time normalize to start at 0 (ns)
      let minT = Infinity, maxT = -Infinity;
      for (const v of t) { if (v < minT) minT = v; if (v > maxT) maxT = v; }
      const tRel = t.map(v => v - minT);

      // normalize tot for turbo
      let minE = Infinity, maxE = -Infinity;
      for (const v of tot) { if (v < minE) minE = v; if (v > maxE) maxE = v; }
      const totNorm = tot.map(v => (maxE > minE) ? (v - minE) / (maxE - minE) : 0);

      // global density (events per pixel) for legend - use 95th percentile to avoid outliers
      const densityCounts = new Map();
      for (let i = 0; i < x.length; i++) {
        const key = `${x[i]}|${y[i]}`;
        densityCounts.set(key, (densityCounts.get(key) || 0) + 1);
      }
      const densityValues = Array.from(densityCounts.values());
      const maxDensityGlobal = densityValues.length > 0 ? percentile(densityValues, 0.95) : 1;

      events = {
        t: tRel,
        x,
        y,
        tot,
        totNorm,
        cid: cid.every(v => v === null) ? null : cid.map(v => (v === null ? 0 : v)),
        energyMin: isFinite(minE) ? minE : 0,
        energyMax: isFinite(maxE) ? maxE : 0,
        densityGlobalMax: maxDensityGlobal > 0 ? maxDensityGlobal : 1
      };

      tMin = 0;
      tMax = maxT - minT;

      // sliders init
      document.getElementById("tCenter").value = 0.1;
      const win = Math.max(1, Math.floor((tMax - tMin) * 0.01));
      const winSlider = document.getElementById("winSize");
      winSlider.min = "1";
      winSlider.max = String(Math.max(1, Math.floor(tMax / 20)));
      winSlider.step = String(Math.max(1, Math.floor((tMax / 20) / 2000)));
      winSlider.value = String(win);

      // If the file doesn't have Cluster_IDs (e.g. raw .t3pa), default the mode away from "classification".
      if (!events.cid) {
        document.getElementById("mode").value = (events.tot && events.tot.length) ? "energy" : "density";
      }

      await renderPlot();
    }

    async function loadClassFile(file) {
      const rowsRaw = await parseWithPapa(file);
      const rows = normalizeColumns(rowsRaw);
      const m = new Map();
      for (const r of rows) {
        const id = pick(r, ["Cluster_ID"], null);
        const cls = pick(r, ["class", "Class"], "Other");
        if (id === null) continue;
        m.set(Number(id), String(cls || "Other"));
      }
      classMap = m;
      await renderPlot();
    }

    // -----------------------------
    // Wire up UI
    // -----------------------------
    document.getElementById("eventsFile").addEventListener("change", async (e) => {
      const f = e.target.files[0];
      if (!f) return;
      document.getElementById("stats").textContent = "Loading events...";
      try {
        await loadEventsFile(f);
      } catch (err) {
        console.error(err);
        alert("Failed to load events file: " + err.message);
      }
    });

    document.getElementById("classFile").addEventListener("change", async (e) => {
      const f = e.target.files[0];
      if (!f) return;
      document.getElementById("stats").textContent = "Loading classification...";
      try {
        await loadClassFile(f);
      } catch (err) {
        console.error(err);
        alert("Failed to load classification file: " + err.message);
      }
    });

    document.getElementById("tCenter").addEventListener("input", () => renderPlot());
    document.getElementById("winSize").addEventListener("input", () => renderPlot());
    document.getElementById("mode").addEventListener("change", () => renderPlot());
    document.getElementById("speed").addEventListener("input", () => renderPlot());

    document.getElementById("resetBtn").addEventListener("click", async () => {
      if (!events) return;
      document.getElementById("tCenter").value = 0.1;
      await renderPlot();
    });

    function stopPlay() {
      isPlaying = false;
      if (playTimer) clearInterval(playTimer);
      playTimer = null;
      document.getElementById("playBtn").textContent = "Play";
    }

    document.getElementById("playBtn").addEventListener("click", () => {
      if (!events) return;
      if (isPlaying) {
        stopPlay();
        return;
      }

      isPlaying = true;
      document.getElementById("playBtn").textContent = "Pause";
      const slider = document.getElementById("tCenter");
      playTimer = setInterval(async () => {
        const v = Number(slider.value);
        // Base step per tick, scaled by speed.
        const speed = Number(document.getElementById("speed").value);
        const next = v + 0.002 * speed;
        slider.value = (next > 1) ? 0 : next;
        await renderPlot();
      }, 50);
    });
  </script>
</body>
</html>


